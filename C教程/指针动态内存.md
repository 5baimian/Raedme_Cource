# 指针+动态内存（malloc）

## 在数组编译时不指定数组大小，可以用指针 + 动态内存（malloc）

### 解释一下

```c

#默认的数组是 静态分配的，大小在编译时就固定了
int arr[100];  // 必须提前确定 100

#但有时我们想根据用户输入来决定数组大小，比如：
int n;
scanf("%d", &n);

这时就需要 运行时分配内存 —— 也就是 动态内存分配。
```

### malloc函数

```c
#函数库：#include <stdlib.h>
#函数原型：
void* malloc(size_t size);

#1、从堆（heap）上申请一块内存
#2、返回一个指向这块内存的“指针”
#3、size 是申请的字节数
#4、用 (类型 *) 强制类型转换

```

### 用法示例

```c
#include <stdio.h>
#include <stdlib.h>  // malloc, free

int main() {

    #1、显性输入数组n的大小
    // int n;
    // printf("请输入数组长度：");
    // scanf("%d", &n);

    // // 1. 使用 malloc 分配 n 个 int 的空间
    // int *arr = (int *)malloc(n * sizeof(int));

    // // 2. 检查是否分配成功
    // if (arr == NULL) {
    //     printf("内存分配失败！\n");
    //     return 1;
    // }

    #2、不显式输入 n，而是直接输入一串整数或字符，让程序自动判断有多少个输入项，再动态分配空间。 scanf + realloc 动态扩容：不输入 n，直接输入整数

    int *arr = NULL;
    int size = 0;
    int capacity = 2;  // 初始容量
    arr = (int *)malloc(capacity * sizeof(int));

    printf("请输入一串整数，以非数字结束（如字母）：\n");

    int x;
    while (scanf("%d", &x) == 1) 
    {
        if (size >= capacity) 
        {
            capacity *= 2;  // 扩容
            arr = (int *)realloc(arr, capacity * sizeof(int));
        }
        arr[size++] = x;
    }



    // 3. 给数组赋值
    for (int i = 0; i < n; i++) {
        arr[i] = i * 10;  // 举例：赋值为 0, 10, 20...
    }

    // 4. 打印数组内容
    printf("数组内容为：\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 5. 用完后释放内存
    free(arr);

    return 0;
}

```

### 错误

```c
int temp[] = {0};
#这是一个 只有 1 个元素的数组，你却往里写多个值，肯定越界访问、段错误！

#想要为变量分配存储空间时，需要为数组动态分配内存
int* temp=(int *)malloc(m*sizeof(int));

malloc函数​返回值​​：返回分配的内存的首地址（类型为 void*，需强制转换为 int*）;

​​if (temp == NULL)​​
​​检查分配是否成功​​：如果内存不足或系统错误，malloc 会返回 NULL。
​​失败处理​​：打印错误信息并退出函数（避免后续操作访问无效内存）。

    if (temp == NULL) {
        printf("内存分配失败！\n");
        return;//提前结束
    }
    
```
